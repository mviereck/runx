#! /bin/bash
# runx: Provide an X server in WSL

Version="v0.2.2"

usage() {                       # Usage information (--help)
  echo "runx - Provide an X server on MS Windows in Cygwin, MSYS2 or WSL.
Run Linux GUI applications on MS Windows.

Syntax:
  runx [OPTIONS]  --  [COMMAND]

Options:
  -h, --help                     Show this help.
  -d, --desktop                  Open a parent window for desktop environments.
  -g, --gpu                      Enable GPU hardware acceleration. Can fail 
                                 with NVIDIA cards. Works best with XWin.
      --clipboard [=yes|no]      Enable clipboard sharing yes/no. Default: yes.
      --vcxsrv                   Use X server VcXsrv.
      --xwin                     Use X server XWin.
      --display N                Use display number N for new X server.
      --no-auth                  Disable X cookie authentication. Discouraged.
      --cleanup                  Stop all X servers and delete cookies.
  -v, --verbose                  Be verbose.

Installation of runx in WSL:
 - Copy runx into /usr/local/bin/
 - Make runx executeable:        sudo chmod +x /usr/local/bin/runx
 - Install xauth and xwininfo:   sudo apt update
                                 sudo apt install xauth x11-utils
 
Install an X server on Windows:
  runx supports two X servers: VcXsrv and XWin. Install at least one of them.
   - VcXsrv: Download and install from: 
       https://sourceforge.net/projects/vcxsrv/
   - XWin: Download and install Cygwin64 with packages: xinit xauth xwininfo
       https://www.cygwin.com
VcXsrv is easier to install. XWin provides a better GPU support.

WSL, Cygwin:       runx starts XWin if available, otherwise it starts VcXsrv.
MSYS2 constraints: runx only supports VcXsrv without cookie authentication.

Usage:

Example to directly run an application with runx:
 - Install file manager pcmanfm: sudo apt update
                                 sudo apt install pcmanfm
 - Run pcmanfm with:             runx -- pcmanfm

Example to run Mate desktop:
 - Install Mate desktop with:    sudo apt install mate-desktop-environment
 - Run Mate desktop with:        runx --desktop -- mate-session
 
Example to get a Wayland environment:
 - Install Wayland compositor:   sudo apt install weston
 - Run Weston with:              XDG_RUNTIME_DIR=/tmp  runx -- weston

Providing an X server in background all the time:
 - Create an entry in ~/.bashrc: source /usr/local/bin/runx
 - In future terminal session you can directly run GUI commands.
   E.g. just type:  'pcmanfm'  instead of 'runx -- pcmanfm'.

runx version $Version
Please report issues at:         https://github.com/mviereck/runx
" >&2
}

finish() {                      # Clean up and terminate
  [ "$RUNX_XPID" ] && ps -p "$RUNX_XPID" >/dev/null 2>&1 && {
    verbose "Terminating X server $RUNX_XPID"
    kill "$RUNX_XPID"
  }
  case "$Sourced" in
    yes)
      unset -f usage finish
      unset -f error warning note verbose
      unset -f rmcr getwslpath escapestring convertpath
      unset -f check_host check_dependency check_dependencies check_displaynumber setup_cookie generate_xcommand
      unset -f cleanup
      unset -f declare_variables parse_options main
      Exitcode="${1:-0}"
    ;;
    no)
      exit "${1:-0}"
    ;;
  esac
}

error() {                       # Show error message and exit
  echo -e "${Colredbg}runx ERROR:${Colnorm} $*
" >&2
  Exitcode=1
}

warning() {                     # Show warning messages
  echo "${Colyellow}runx WARNING:${Colnorm} $*
" >&2
}

note() {                        # Show notice messages
  echo "${Colgreen}runx note:${Colnorm} $*
" >&2
}

verbose() {                     # Show verbose message (--verbose)
  [ "$Verbose" = "yes" ] && note "$*"
}

#### general routines

rmcr() {                        # Remove carriage return to translate DOS/Windows newlines into UNIX newlines.
  # Convert stdin if $1 is empty. Otherwise convert file $1.
  case "${1:-}" in
    "") sed    "s/$(printf "\r")//g" ;;
    *)  sed -i "s/$(printf "\r")//g"  "${1:-}"
  esac
}

getwslpath() {                  # get path to currently running WSL system

  # Fork from https://github.com/Microsoft/WSL/issues/2578#issuecomment-354010141
  
  local RUN_ID= BASE_PATH=
  
  RUN_ID="/tmp/$(mcookie)"

  # Mark our filesystem with a temporary file having an unique name.
  touch "${RUN_ID}"

  powershell.exe -Command '(Get-ChildItem HKCU:\Software\Microsoft\Windows\CurrentVersion\Lxss | ForEach-Object {Get-ItemProperty $_.PSPath}).BasePath.replace(":", "").replace("\", "/")' | while IFS= read -r BASEPATH; do
    # Remove trailing whitespaces.
    BASEPATH="${BASEPATH%"${BASEPATH##*[![:space:]]}"}"
    # Build the path on WSL.
    BASEPATH="/mnt/${BASEPATH,}/rootfs"

    # Current WSL instance doesn't have an access to its mount from within
    # itself despite all others are available. That's the hacky way we're
    # using to determine current instance.
    #
    # The second of part of the condition is a fallback for a case if our
    # trick will stop working. For that we've created a temporary file with
    # an unique name and now seeking it among all WLSs.
    if ! ls "${BASEPATH}" > /dev/null 2>&1 || [ -f "${BASEPATH}${RUN_ID}" ]; then
      echo "${BASEPATH}"
      # You can create and simultaneously run multiple WSL instances, comment
      # out the "break", run this script within each one and it'll return only
      # single value.
      break
    fi
  done
  rm "${RUN_ID}"
  return 0
}

escapestring() {                # Escape special chars of $1
  # escape all characters except those described in [^a-zA-Z0-9,._+@=:/-]
  echo "${1:-}" | LC_ALL=C sed -e 's/[^a-zA-Z0-9,._+@=:/-]/\\&/g; 1{$s/^$/""/}; 1!s/^/"/; $!s/$/"/'
}

convertpath() {                 # Convert unix and windows pathes
  # $1: Mode:
  #   --windows   echo windows path                - result: C:/path
  #   --unix      echo unix path                   - result: /c/path
  #   --subsystem echo path within subsystem       - result: /cygdrive/c/path  or  /path
  #   --volume    echo --volume compatible syntax  - result: 'unixpath':'containerpath':rw  (or ":ro")
  #   --container echo path of volume in container - result: /path
  # $2: Path to convert. Arbitrary syntax, can be C:/path, /c/path, /cygdrive/c/path, /path
  #     Can have suffix :rw or :ro. If none is given, return with :rw
  # $3: Optional for --volume: containerpath
  
  local Mode= Path= Drive= Readwritemode=
  
  Mode="${1:-}"
  Path="${2:-}"

  # check path for suffix :rw or :ro
  Readwritemode="$(echo "$Path" | rev | cut -c1-3 | rev)"
  [ "$(cut -c1 <<< "$Readwritemode")" = ":" ] && {
    Path="$(echo "$Path" | rev | cut -c4- | rev)"
  } || Readwritemode=":rw"

  # replace ~ with HOME
  Path="$(sed s%"~"%"${Hostuserhome:-${HOME:-}}"% <<< "$Path")"
  
  # not on Windows
  [ -z "$Winsubsystem" ] && {
    case $Mode in
      --unix|--subsystem) echo "$Path" ;;
      --windows) warning "Nonsense path conversion $Mode: $Path" ; return 1 ;;
      --volume) echo "'$Path':'${3:-$Path}'$Readwritemode" ;;
      --container) echo "${3:-$Path}" ;;
    esac
    return 0
  }
  
  # replace \ with /
  Path="$(tr '\\' '/' <<< "$Path")"
  
  # remove possible already given mountpoint
  Path="${Path#$Winsubmount}"
  
  # Given format is /c/
  [ "$(cut -c1,3 <<< "$Path")" = "//" ] && {
    Drive="$(cut -c2 <<< "$Path")"
    Path="$(cut -c3- <<< "$Path")"
  }
  
  # Given format is C:/
  [ "$(cut -c2 <<< "$Path")" = ":" ] && {
    Drive="$(cut -c1 <<< "$Path")"
    Path="$(cut -c3- <<< "$Path")"
  }
  
  # change C to c
  Drive="${Drive,}"

  [ "$Winsubsystem" = "WSL" ] && [ -z "$Drive" ] && case $Mode in
    --windows|--unix|--volume)
      warning "Request of Windows path to path within WSL:
  $Path
  Write access from Windows host to WSL files can damage WSL.
  Read-only access is ok."
    ;;
  esac

  case $Drive in
    "") # Path points into subsystem
      Path="${Path#"$Winsubpath"}"
      Drive="$(cut -c2 <<<"$Winsubpath")"
      case $Mode in
        --windows)   echo "${Drive^}:$(cut -c3- <<<$Winsubpath)$Path" ;;
        --unix)      echo "$Winsubpath$Path" ;;
        --subsystem) echo "$Path" ;;
        --volume)    echo "'$Winsubpath$Path':'${3:-$Path}'$Readwritemode" ;;
        --container) echo "${3:-$Path}" ;;
      esac
    ;;
    *) # Path outside of subsystem
      case $Mode in
        --windows)   echo "${Drive^}:$Path" ;;
        --unix)      echo "/$Drive$Path" ;;
        --subsystem) echo "$Winsubmount/$Drive$Path" ;;
        --volume)    echo "'/$Drive$Path':'${3:-/$Drive$Path}'$Readwritemode" ;;
        --container) echo "${3:-/$Drive$Path}" ;;
      esac
    ;;
  esac
  return 0
}

#### setup

check_host() {                  # Check host environment

  # Check for MS Windows subsystem
  uname -r | grep -q Microsoft                    && Winsubsystem="WSL"
  command -v cygcheck.exe >/dev/null && {
    cygcheck.exe -V | rmcr | grep -q "(cygwin)"   && Winsubsystem="CYGWIN"
    cygcheck.exe -V | rmcr | grep -q "(msys)"     && Winsubsystem="MSYS2"
  }
  
  [ "$0" = "$BASH_SOURCE" ] && Sourced="no" || Sourced="yes"
  verbose "Script is being sourced yes/no: $Sourced"
  
  case $Winsubsystem in
    MSYS2|CYGWIN) 
      Winsubmount="$(cygpath.exe -u "c:/" | rmcr | sed s%/c/%%)"
      Winsubpath="$(convertpath --unix "$(cygpath.exe -w "/" | rmcr)" )" ;;
    WSL)          
      Winsubmount="/mnt"
      grep -q "Windows" <<< "${PATH:-}" || export PATH="${PATH:-}:$Winsubmount/c/Windows/System32:$Winsubmount/c/Windows/System32/WindowsPowerShell/v1.0" # can miss after sudo
      Winsubpath="$(convertpath --unix "$(getwslpath)")" ;;
  esac
  
  # Check IP of Windows host
  Hostip="$(ipconfig.exe | rmcr | grep -A6 'DockerNAT' | grep 'IPv4' | rev | cut -d' ' -f1 | rev)"
  [ "$Hostip" ] || Hostip="$(ipconfig.exe | rmcr | grep 'IPv4' | grep -o '[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*' | grep "^10\.0\.*" )"
  [ "$Hostip" ] || Hostip="$(ipconfig.exe | rmcr | grep 'IPv4' | head -n1 | | rev | cut -d' ' -f1 | rev)"
  verbose "Host IP adress: $Hostip"
  
  [ "$Xauthentication" = "yes" ] && [ "$Winsubsystem" = "MSYS2" ] && {
    note "MSYS2 does not provide xauth to create a cookie.
  Fallback: Enabling discouraged option --no-auth."
    Xauthentication="no"
  }
  
  return 0
}

check_dependency() {            # Check for single command
  [ "${1:-}" ] || return 1
  command -v "${1:-}" >/dev/null || {
    note "Command not found: ${1:-}"
    return 1
  }
  return 0
}

check_dependencies() {          # Check all dependencies
  local Line
  
  # subsystem
  case "$Winsubsystem" in
    WSL|CYGWIN|MSYS2) ;;
    *) error "runx is designed to run on MS Windows in WSL, Cygwin or MSYS2.
  Did not detect WSL, Cygwin or MSYS2." ;; ###
  esac
  [ "$Winsubsystem" = "MSYS2" ] && [ "$Xserver" = "xwin" ] && {
    note "runx in MSYS2 does not support --xwin.
  Fallback: Enabling option --vcxsrv."
    Xserver="vcxsrv"
  }
  
  # xauth
  [ "$Xauthentication" = "yes" ] && {
    check_dependency xauth || error "Missing dependency: xauth
  Cannot create an authorization cookie for X server access.
  Please install package in $Winsubsystem:  xauth
  You can disable cookie authentication with discouraged option --no-auth."
  }
  
  # xwininfo
  [ "$Newdisplaynumber" ] || {
    check_dependency xwininfo || {
      Newdisplaynumber="$((RANDOM / 10))"
      warning "Missing dependency: xwininfo
  Cannot check for a free display number.
  Fallback: Using random display number $Newdisplaynumber.
  If this display number is already in use, the startup will fail.
  You can specify a custom display number with option --display=N.
  $([ "$Winsubsystem" = "MSYS2" ] || echo "  Please install package in $Winsubsystem:  xwininfo  or  x11-utils" )"
    }
  }
  
  # mcookie ### FIXME
  
  # X server VcXsrv or XWin
  Vcxsrvexe="$(command -v vcxsrv.exe)"
  [ "$Vcxsrvexe" ] || Vcxsrvexe="$(command -v "$(convertpath --subsystem "C:/Program Files/VcXsrv/vcxsrv.exe")")"
  Xwinexe="$(command -v XWin)"
  [ -z "$Xwinexe" ] && [ "$Winsubsystem" = "WSL" ] && {
    # search for XWin
    for Drive in /mnt/*; do
      Xwinexe="$(command -v "$Drive/cygwin64/bin/XWin.exe")"
      [ "$Xwinexe" ] && break
      Xwinexe="$(command -v "$Drive/cygwin32/bin/XWin.exe")"
      [ "$Xwinexe" ] && break
    done
  }
  verbose "Found X servers:
  $Vcxsrvexe
  $Xwinexe"
  
  [ -z "$Xserver" ] && [ -n "$Xwinexe" ]  && Xserver="xwin"
  [ -z "$Xserver" ]                       && Xserver="vcxsrv"
  [ "$Winsubsystem" = "MSYS2" ]           && Xserver="vcxsrv"
  
  case "$Xserver" in
    vcxsrv) Xserverexe="$Vcxsrvexe" ;;
    xwin)   Xserverexe="$Xwinexe" ;;
  esac
  
  [ -z "$Xserverexe" ] && {
    case $Winsubsystem in
      WSL|CYGWIN) error "No X server found. 
  Please either install X server VcXsrv:
      https://sourceforge.net/projects/vcxsrv
  or install Cygwin with packages xinit, xauth and xwininfo to provide XWin:
      https://www.cygwin.com/" ;;
      MSYS2)      error "No X server found for MSYS2. 
  Please install X server VcXsrv:
      https://sourceforge.net/projects/vcxsrv" ;;
    esac
  }
  
  # Windows commands
  for Line in cmd.exe ipconfig.exe powershell.exe tasklist.exe taskkill.exe; do
    check_dependency "$Line" || error "Did not find Windows command: $Line"
  done
}

check_displaynumber() {         # Find free display number, print on stdout
  verbose "Searching for free display number."
  for ((Newdisplaynumber=100 ; Newdisplaynumber <=1000 ; Newdisplaynumber++)); do
    grep -q -E 'Authorization|Absolute|MIT-MAGIC-COOKIE' <<< "$(xwininfo -display $Hostip:$Newdisplaynumber -root 2>&1)" || break
  done
  verbose "Found free display number: $Newdisplaynumber"
}

setup_cookie() {                # Generate X authentication cookie
  local Cookie
  
  Xclientcookie="$(convertpath --subsystem "~/runx_Xauthority")"
  Xservercookie="$(convertpath --subsystem "$(cmd.exe /C "echo %userprofile%")" | rmcr)/runx_Xauthority"
  
  verbose "Cookies:
  $Xservercookie
  $Xclientcookie"

  # remove old cookies if no VcXsrv is running yet
  command -v tasklist.exe >/dev/null && {
    tasklist.exe | rmcr | grep -q -E 'vcxsrv.exe|XWin.exe' || {
      verbose "Removing old cookies."
      [ -e "$Xservercookie" ] && rm "$Xservercookie"
      [ -e "$Xclientcookie" ] && rm "$Xclientcookie"
    }
  }
  
  touch "$Xclientcookie"
  touch "$Xservercookie"
  
  # generate fresh cookie
  xauth -i -f "$Xclientcookie" add :$Newdisplaynumber . $(mcookie)
  # prepare cookie with localhost identification disabled by ffff. ffff means 'familiy wild'
  Cookie="$(xauth -i -f "$Xclientcookie" nlist | sed -e 's/^..../ffff/')"
  echo "$Cookie" | xauth -i -f "$Xclientcookie" nmerge -
  echo "$Cookie" | xauth -i -f "$Xservercookie" nmerge -
  
  verbose "Client cookie:
$(xauth -v -f "$Xclientcookie" list)"
  verbose "Server cookie:
$(xauth -v -f "$Xservercookie" list)"
}

generate_xcommand() {           # Generate command to start X server VcXsrv
  

  Xcommand="$(escapestring "$Xserverexe") :$Newdisplaynumber -listen tcp -retro -lesspointer"
  
  # GPU hardware acceleration
  case $Sharegpu in
    yes) Xcommand="$Xcommand -wgl   +iglx" ; export LIBGL_ALWAYS_INDIRECT=1 
      [ "$Xserver" = "vcxsrv" ] && note "GPU support of VcXsrv has some issues.
  If it does not work or crashes, try runx with option --xwin instead."
    ;;
    no)  Xcommand="$Xcommand -nowgl -iglx" ; unset  LIBGL_ALWAYS_INDIRECT   ;;
  esac
  
  # Seamless or desktop mode
  [ "$Desktopmode" = "no" ] && Xcommand="$Xcommand -multiwindow"
      
  # Clipboard
  case $Shareclipboard in
    yes) Xcommand="$Xcommand -clipboard" ;;
    no)  Xcommand="$Xcommand -noclipboard" ;;
  esac

  case $Xauthentication in
    yes) 
      case "$Xserver" in
        xwin) case "$Winsubsystem" in
                CYGWIN)   Xcommand="$Xcommand -auth '$Xservercookie'" ;;
                WSL)      Xcommand="$Xcommand -auth '/cygdrive${Xservercookie#$Winsubmount}'" ;;
              esac ;;
        vcxsrv)           Xcommand="$Xcommand -auth '$(convertpath --windows "$Xservercookie")'" ;;
      esac ;;
    no)                   Xcommand="$Xcommand -ac" ;;
  esac
  
  # X server extensions
  Xcommand="$Xcommand \
  +extension RANDR \
  +extension RENDER \
  +extension GLX \
  +extension DOUBLE-BUFFER \
  +extension DAMAGE \
  +extension COMPOSITE \
  -extension X-Resource \
  -extension XTEST"
  
  verbose "Generated X command:
  $Xcommand"
}

#### special jobs

cleanup() {                     # --cleanup: Terminate X servers, delete cookies.
  # kill all instances of VcXsrv and remove cookies
  MSYS2_ARG_CONV_EXCL='*' tasklist.exe | rmcr | grep -E 'vcxsrv.exe|XWin.exe'
  MSYS2_ARG_CONV_EXCL='*' taskkill.exe /F /PID vcxsrv.exe
  MSYS2_ARG_CONV_EXCL='*' taskkill.exe /F /PID xwin.exe
  # Remove cookies
  Newdisplaynumber=0
  setup_cookie
  rm -v "$Xclientcookie" "$Xservercookie"
}

#### main

declare_variables() {
  # Default values
  Desktopmode="no"
  Screensize="" ### FIXME
  Shareclipboard="yes"
  Sharegpu="no"
  Verbose="no"
  Xauthentication="yes"
  
  # Terminal colors used for messages and --verbose=c
  Esc="$(printf '\033')"
  Colblue="${Esc}[35m"
  Colyellow="${Esc}[33m"
  Colgreen="${Esc}[32m"
  Colgreenbg="${Esc}[42m"
  Colred="${Esc}[31m"
  Colredbg="${Esc}[41m"
  Coluline="${Esc}[4m"
  Colnorm="${Esc}[0m"
  
  # Empty global vars needed later
  Exitcode=""
  Hostip=""
  Logfile=""
  Newdisplaynumber=""
  Sourced=""
  Vcxsrvexe=""
  Winsubmount=""
  Winsubpath=""
  Xcommand=""
  Xserver=""
  Xserverexe=""
  Xwinexe=""
}

parse_options() {
  local Shortoptions Longoptions Parsererror
  
  Shortoptions="dghv"
  Longoptions="desktop,gpu,clipboard::,display:,no-auth,help,verbose,version,cleanup,vcxsrv,xwin"
  
  Parsedoptions="$(getopt --options $Shortoptions --longoptions $Longoptions --name "$0" -- "$@" 2>/tmp/runx_parsererror)"
  [ -e /tmp/runx_parsererror ] && Parsererror=$(cat /tmp/runx_parsererror) && rm /tmp/runx_parsererror
  [ "$Parsererror" ] && error "$Parsererror"
  eval set -- "$Parsedoptions"
  verbose "$Parsedoptions"
  
  while [ $# -gt 0 ]; do
    case "${1:-}" in
         --version)       echo "runx version $Version"; Exitcode=0 ;;
         --no-auth)       Xauthentication="no" ;;
         --cleanup)       Cleanup="yes" ;;
         --clipboard)     Clipboard="${2:-yes}"; shift ;;
      -d|--desktop)       Desktopmode="yes" ;;
         --display)       Newdisplaynumber="${2:-}" ; shift ;;
      -g|--gpu)           Sharegpu="yes" ;;
      -h|--help)          usage; finish ;;
      -v|--verbose)       Verbose="yes" ;;
         --vcxsrv|--xwin) Xserver="${1:-}" ; Xserver="${Xserver#--}" ;;
      --) shift;          Hostcommand="$@"; break ;;
      *) error "Unknown option: ${1:-}
  $(usage 2>&1)"
    esac
    shift
  done
}

main() {
  local Waiting

  [ "$Newdisplaynumber" ] || check_displaynumber
  [ "$Xauthentication" = "yes" ] && setup_cookie
  generate_xcommand

  [ "$Sourced" = "no" ] && note "Windows firewall settings can forbid application access
  to the X server. If no application window appears, but no obvious error
  is shown, please check your firewall settings. 
  Compare:   https://github.com/mviereck/x11docker/issues/108"
  
  # set DISPLAY and XAUTHORITY, output on stdout
  export DISPLAY=$Hostip:$Newdisplaynumber
  case "$Xauthentication" in
    yes)
      export XAUTHORITY="$Xclientcookie"
      verbose "DISPLAY=$DISPLAY XAUTHORITY=$XAUTHORITY"
      note "If you get application error messages like 'Cannot open display'
  or 'Invalid MIT-MAGIC-COOKIE', the X cookie might be broken.
  You can remove old cookies and stop running X servers with: runx --cleanup"
      echo "DISPLAY=$DISPLAY XAUTHORITY=$XAUTHORITY"
    ;;
    no)
      unset XAUTHORITY
      verbose "DISPLAY=$DISPLAY"
      warning "Option --no-auth: Cookie authentication is disabled!
  Your X server $Xserver listens on TCP connections without any protection!
  This is a security leak. Please use option --no-auth for debugging only."
      echo "DISPLAY=$DISPLAY"
    ;;
  esac
  
  # set up X log
  Logfile="/tmp/runx_X${Newdisplaynumber}.log"
  :> "$Logfile"
  [ "$Verbose" = "yes" ] && {
    tail -f "$Logfile" 1>&2 &
  }
  Xcommand="$Xcommand >> '$Logfile' 2>&1"
  
  # Run X in background?
  { [ "$Hostcommand" ] || [ "$Sourced" = "yes" ] ; }  && Xcommand="$Xcommand & RUNX_XPID=\$!"

  eval $Xcommand 
  
  # Check for successfull startup
  [ "$RUNX_XPID" ] && {
    export RUNX_XPID
    verbose "PID of X server: $RUNX_XPID
  $(ps -p "$RUNX_XPID")"
    case "$Xserver" in
      xwin)
        for Waiting in 1 2 3 4 5 6 7 8 9 10; do
          sleep 1
          grep -q "successfully opened the display" "$Logfile" && break
        done
        [ "$Waiting" = "10" ] && error "X server XWin not ready after 10s."
      ;;
      vcxsrv) sleep 1 ;;
    esac
  } || unset RUNX_XPID
  
  [ "$Sourced" = "yes" ]     && export RUNX_SOURCED=1 || unset RUNX_SOURCED
  [ "$Desktopmode" = "yes" ] && export RUNX_DESKTOP=1 || unset RUNX_DESKTOP
  
  # Run host command
  [ -z "$Exitcode" ] && [ "$Hostcommand" ] && {
    verbose "Executing command:
  $Hostcommand"
    eval $Hostcommand
  }
}

declare_variables
parse_options "$@"
check_host
check_dependencies
[ "$Cleanup" = "yes" ] && cleanup && Exitcode="${Exitcode:-0}"
[ -z "$Exitcode" ]     && main
finish "${Exitcode:-0}"
